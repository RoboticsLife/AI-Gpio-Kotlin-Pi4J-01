package avatar.hardware.parts

import avatar.hardware.parts.basecomponents.I2CDevice
import avatar.hardware.parts.basecomponents.PositionSensor
import brain.data.local.Configuration
import brain.data.local.Position
import brain.utils.toI2CDeviceConfiguration
import com.pi4j.context.Context
import com.pi4j.io.i2c.I2C
import kotlinx.coroutines.*
import kotlin.math.abs
import kotlin.math.atan
import kotlin.math.atan2
import kotlin.math.sqrt

class MPU6050(pi4j: Context, positionSensorConfig: Configuration.PositionSensorConfig): PositionSensor, I2CDevice(
    pi4j = pi4j, i2CDeviceConfiguration = positionSensorConfig.toI2CDeviceConfiguration()
) {

    //Value used for the DLPF config.
    private var dlpfCfg: Int = positionSensorConfig.dlpfCfg ?: 0
    //Value used for the sample rate divider.
    private var smplrtDiv: Int = positionSensorConfig.smplrtDiv ?: 0
    //Sensitivity of the measures from the accelerometer. Used to convert accelerometer values.
    private var accelLSBSensitivity: Double = 0.0
    //Sensitivity of the measures from the gyroscope. Used to convert gyroscope values to degrees/sec.
    private var gyroLSBSensitivity: Double = 0.0

    private var updatingJob: Job? = null
    private var updatingThreadStopped: Boolean = true
    private var lastUpdateTime: Long = 0

    // ACCELEROMETER
    //Last acceleration value, in g, retrieved from the accelerometer, for the X axis. (using updatingJob)
    private var accelAccelerationX: Double = 0.0
    //Last acceleration value, in g, retrieved from the accelerometer, for the Y axis. (using updatingJob)
    private var accelAccelerationY: Double = 0.0
    //Last acceleration value, in g, retrieved from the accelerometer, for the Z axis. (using updatingJob)
    private var accelAccelerationZ: Double = 0.0
    //Last angle value, in °, retrieved from the accelerometer, for the X axis. (using updatingJob)
    private var accelAngleX: Double = 0.0
    //Last angle value, in °, retrieved from the accelerometer, for the Y axis. (using updatingJob)
    private var accelAngleY: Double = 0.0
    //Last angle value, in °, retrieved from the accelerometer, for the Z axis. (using updatingJob)
    private var accelAngleZ: Double = 0.0

    //GYROSCOPE
    //Last angular speed value, in °/sec, retrieved from the gyroscope, for the X axis. (using updatingJob)
    private var gyroAngularSpeedX: Double = 0.0
    //Last angular speed value, in °/sec, retrieved from the gyroscope, for the Y axis. (using updatingJob)
    private var gyroAngularSpeedY: Double = 0.0
    //Last angular speed value, in °/sec, retrieved from the gyroscope, for the Z axis. (using updatingJob)
    private var gyroAngularSpeedZ: Double = 0.0
    //Last angle value, in °, calculated from the gyroscope, for the X axis. (using updatingJob)
    private var gyroAngleX: Double = 0.0
    //Last angle value, in °, calculated from the gyroscope, for the Y axis. (using updatingJob)
    private var gyroAngleY: Double = 0.0
    //Last angle value, in °, calculated from the gyroscope, for the Z axis. (using updatingJob)
    private var gyroAngleZ: Double = 0.0
    //Calculated offset for the angular speed from the gyroscope, for the X axis.
    private var gyroAngularSpeedOffsetX: Double = 0.0
    //Calculated offset for the angular speed from the gyroscope, for the Y axis.
    private var gyroAngularSpeedOffsetY: Double = 0.0
    //Calculated offset for the angular speed from the gyroscope, for the Z axis.
    private var gyroAngularSpeedOffsetZ: Double = 0.0

    //FILTERED
    //Last angle value, in °, calculated from the accelerometer and the gyroscope, for the X axis. (using updatingJob)
    private var filteredAngleX: Double = 0.0
    //Last angle value, in °, calculated from the accelerometer and the gyroscope, for the Y axis. (using updatingJob)
    private var filteredAngleY: Double = 0.0
    //Last angle value, in °, calculated from the accelerometer and the gyroscope, for the Z axis. (using updatingJob)
    private var filteredAngleZ: Double = 0.0



    override fun initDevice(i2C: I2C) {
        // 1. waking up the MPU6050 (0x00 = 0000 0000) as it starts in sleep mode.
        updateRegisterValue(MPU6050_REG_ADDR_PWR_MGMT_1, 0x00)

        // 2. sample rate divider
        // The sensor register output, FIFO output, and DMP sampling are all based on the Sample Rate.
        // The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:
        //      Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
        // where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or 7),
        // and 1kHz when the DLPF is enabled (see register 26).
        // SMPLRT_DIV set the rate to the default value : Sample Rate = Gyroscope Rate.
        updateRegisterValue(MPU6050_REG_ADDR_SMPRT_DIV, smplrtDiv)

        // 3. This register configures the external Frame Synchronization (FSYNC)
        // pin sampling and the Digital Low Pass Filter (DLPF) setting for both
        // the gyroscopes and accelerometers.
        setDLPFConfig(dlpfCfg)


        // 4. Gyroscope configuration
        // FS_SEL selects the full scale range of the gyroscope outputs.
        val fsSel = (0 shl 3).toByte() // FS_SEL +- 250 °/s
        gyroLSBSensitivity = 131.0 // cfr [datasheet 2 - p.31]
        updateRegisterValue(MPU6050_REG_ADDR_GYRO_CONFIG, fsSel.toInt())


        // 5. Accelerometer configuration [datasheet 2 - p.29]
        val afsSel: Byte = 0 // AFS_SEL full scale range: ± 2g. LSB sensitivity : 16384 LSB/g
        accelLSBSensitivity = 16384.0 // LSB Sensitivity corresponding to AFS_SEL 0
        updateRegisterValue(MPU6050_REG_ADDR_ACCEL_CONFIG, afsSel.toInt())

        // 6. Disable interrupts
        updateRegisterValue(MPU6050_REG_ADDR_INT_ENABLE, 0x00)

        // 7. Disable standby mode
        updateRegisterValue(MPU6050_REG_ADDR_PWR_MGMT_2, 0x00)

        calibrateSensors()
    }

    /* -----------------------------------------------------------------------
     *                             METHODS
     * -----------------------------------------------------------------------*/


    /**
     * Returns the Sample Rate of the MPU6050.
     *
     * [datasheet 2 - p.12] The sensor output, FIFO output, and DMP sampling are
     * all based on the Sample Rate ('Fs' in the datasheet).
     *
     * The Sample Rate is generated by dividing the gyroscope output rate
     * by SMPLRT_DIV:
     * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
     * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or 7),
     * and 1kHz when the DLPF is enabled (see Register 26)
     *
     * Note: The accelerometer output rate is 1kHz (accelerometer and not gyroscope !).
     * This means that for a Sample Rate greater than 1kHz, the same accelerometer
     * sample may be output to the FIFO, DMP, and sensor registers more than once.
     *
     * @return the sample rate, in Hz.
     */
    fun getSampleRate(): Int {
        val gyroscopeOutputRate =
            if (dlpfCfg == 0 || dlpfCfg == 7) 8000 else 1000 // 8kHz if DLPG disabled, and 1kHz if enabled.
        return gyroscopeOutputRate / (1 + smplrtDiv)
    }

    /**
     * Sets the value of the DLPF config, according to the datasheet informations.
     *
     * The accelerometer and gyroscope are filtered according to the value of
     * DLPF_CFG as shown in the table [datasheet 2 - p.13].
     *
     * @param dlpfConfig the new DLPF_CFG value. Must be in the [0; 7] range,
     * where 0 and 7 are used to disable the DLPF.
     */
    fun setDLPFConfig(dlpfConfig: Int) {
        require(!(dlpfConfig > 7 || dlpfConfig < 0)) { "The DLPF config must be in the 0..7 range." }
        dlpfCfg = dlpfConfig
        updateRegisterValue(MPU6050_REG_ADDR_CONFIG, dlpfCfg)
    }

    /**
     * Reads the most recent accelerometer values on MPU6050 for X, Y and Z axis,
     * and calculates the corresponding accelerations in g, according to the
     * selected AFS_SEL mode.
     * @return [ACCEL_X, ACCEL_Y, ACCEL_Z], the accelerations in g for the x, y and z axis.
     */
    fun readScaledAccelerometerValues(): DoubleArray? {
        var accelX = readWord2C(MPU6050_REG_ADDR_ACCEL_XOUT_H).toDouble()
        accelX /= accelLSBSensitivity
        var accelY = readWord2C(MPU6050_REG_ADDR_ACCEL_YOUT_H).toDouble()
        accelY /= accelLSBSensitivity
        var accelZ = readWord2C(MPU6050_REG_ADDR_ACCEL_ZOUT_H).toDouble()
        accelZ /= accelLSBSensitivity

        return doubleArrayOf(accelX, accelY, -accelZ)
    }






    override fun reset() {
    }

    override fun getPositionData(): Position {
        //TODO("Not yet implemented")
        //TODO Alik
        outputAllMeasures()
        return Position(0, "MPU6050", "BBOON")
    }

    override fun getGyroscopePositionData(): Position {
        TODO("Not yet implemented")
        return Position(0, "MPU6050", "BBOON")
    }

    override fun getGPSPositionData(): Position {
        TODO("Not yet implemented")
        return Position(0, "MPU6050", "BBOON")
    }

    //TODO only for tests
    fun outputAllMeasures() {
        val allAngles = getAccelAngles()
        val accelAccelerations = getAccelAccelerations()
        val gyroAngles = getGyroAngles()
        val gyroAngularSpeeds = getGyroAngularSpeeds()
        val filteredAngles = getFilteredAngles()

        //println("allAngles = $allAngles")
        //println("accelAccelerations = $accelAccelerations")
        //println("gyroAngles = $gyroAngles")
        println("gyroAngularSpeeds = ${gyroAngularSpeeds?.get(0)}, ${gyroAngularSpeeds?.get(1)}, ${gyroAngularSpeeds?.get(2)},")
        println("filteredAngles!!!!!!!!!!!! = ${filteredAngles?.get(0)}, ${filteredAngles?.get(1)}, ${filteredAngles?.get(2)}")

    }


    /** Calibrate the accelerometer and gyroscope sensors. */
    private fun calibrateSensors() {
        val calibrateThread = CoroutineScope(Job() + Dispatchers.IO).launch {
            println("Calibration starting in 5 seconds (don't move the sensor).")
            delay(5000)
            println("Calibration started (~5s) (don't move the sensor).")

            val nbReadings = 50
            // Gyroscope offsets
            gyroAngularSpeedOffsetX = 0.0
            gyroAngularSpeedOffsetY = 0.0
            gyroAngularSpeedOffsetZ = 0.0
            for (i in 0..<nbReadings) {
                val angularSpeeds: DoubleArray = readScaledGyroscopeValues()
                gyroAngularSpeedOffsetX += angularSpeeds[0]
                gyroAngularSpeedOffsetY += angularSpeeds[1]
                gyroAngularSpeedOffsetZ += angularSpeeds[2]
                delay(100)
            }
            gyroAngularSpeedOffsetX /= nbReadings.toDouble()
            gyroAngularSpeedOffsetY /= nbReadings.toDouble()
            gyroAngularSpeedOffsetZ /= nbReadings.toDouble()
            println("Calibration ended")

            //TODO tests Alik
            startUpdatingThread()
        }
    }

    /**
     * This method updates the value of a specific register with a specific value.
     * The method also checks that the update was successfull.
     * @param address the address of the register to update.
     * @param value the new value to set in the register.
     */
    fun updateRegisterValue(address: Int, value: Int) {
        writeRegister(address, value)

        // we check that the value of the register has been updated
        val readRegisterValue: Int = readRegister(address)

        if (readRegisterValue != value) throw Exception(
            "Error when updating the MPU6050 register value (register: " +
                    address + ", value: " + value + ")"
        )
    }


    /**
     * Reads the most recent gyroscope values on the MPU6050 for X, Y and Z axis,
     * and calculates the corresponding angular speeds in degrees/sec,
     * according to the selected FS_SEL mode.
     * @return [GYRO_X, GYRO_Y, GYRO_Z], the angular velocities in degrees/sec for the x, y and z axis.
     */
    fun readScaledGyroscopeValues(): DoubleArray {
        var gyroX: Double = readWord2C(MPU6050_REG_ADDR_GYRO_XOUT_H).toDouble()
        gyroX /= gyroLSBSensitivity
        var gyroY: Double = readWord2C(MPU6050_REG_ADDR_GYRO_YOUT_H).toDouble()
        gyroY /= gyroLSBSensitivity
        var gyroZ: Double = readWord2C(MPU6050_REG_ADDR_GYRO_ZOUT_H).toDouble()
        gyroZ /= gyroLSBSensitivity

        return doubleArrayOf(gyroX, gyroY, gyroZ)
    }

    /**
     * Reads the content of two consecutive registers, starting at registerAddress,
     * and returns the int representation of the combination of those registers,
     * with a two's complement representation.
     * @param registerAddress the address of the first register to read.
     * @return the int representation of the combination of the two consecutive
     * registers, with a two's complement representation.
     */
    private fun readWord2C(registerAddress: Int): Int {
        var value: Int = readRegisterValue(registerAddress)
        value = value shl 8
        value += readRegisterValue(registerAddress + 1)

        if (value >= 0x8000) value = -(65536 - value)
        return value
    }

    /**
     * Reads the content of a specific register of the MPU6050.
     * @param registerAddress the address of the register to read.
     * @return the int representation of the content of the register.
     */
    private fun readRegisterValue(registerAddress: Int): Int {
        return readUnsignedRegisterValue(registerAddress)
    }

    /**
     * Starts the thread responsible to update MPU6050 values in background.
     */
    fun startUpdatingThread() {
        updatingJob?.cancel()
        updatingJob = CoroutineScope(Job() + Dispatchers.IO).launch {
            while (true) {
                lastUpdateTime = System.currentTimeMillis()
                updatingThreadStopped = false
                updateValues()
                delay(50) //TODO check if it works and set programmatically updating delay
            }

        }
    }

    /**
     * Stops the thread responsible to update MPU6050 values in background.
     * @throws InterruptedException if any thread has interrupted the current thread.
     * The interrupted status of the current thread is cleared when this exception is thrown.
     */
    fun stopUpdatingThread() {
        updatingThreadStopped = true
        updatingJob?.cancel()
    }


    /**
     * Update values for the accelerometer angles, gyroscope angles and filtered angles values.
     *
     * *This method is used with the updating thread.*
     */
    private fun updateValues() {
        // Accelerometer
        val accelerations: DoubleArray = readScaledAccelerometerValues()!!
        accelAccelerationX = accelerations[0]
        accelAccelerationY = accelerations[1]
        accelAccelerationZ = accelerations[2]
        accelAngleX = getAccelXAngle(accelAccelerationX, accelAccelerationY, accelAccelerationZ)
        accelAngleY = getAccelYAngle(accelAccelerationX, accelAccelerationY, accelAccelerationZ)
        accelAngleZ = getAccelZAngle()


        // Gyroscope
        val angularSpeeds = readScaledGyroscopeValues()
        gyroAngularSpeedX = angularSpeeds[0] - gyroAngularSpeedOffsetX
        gyroAngularSpeedY = angularSpeeds[1] - gyroAngularSpeedOffsetY
        gyroAngularSpeedZ = angularSpeeds[2] - gyroAngularSpeedOffsetZ
        // angular speed * time = angle
        val dt = abs(System.currentTimeMillis() - lastUpdateTime) / 1000.0 // s
        val deltaGyroAngleX = gyroAngularSpeedX * dt
        val deltaGyroAngleY = gyroAngularSpeedY * dt
        val deltaGyroAngleZ = gyroAngularSpeedZ * dt
        lastUpdateTime = System.currentTimeMillis()

        gyroAngleX += deltaGyroAngleX
        gyroAngleY += deltaGyroAngleY
        gyroAngleZ += deltaGyroAngleZ


        // Complementary Filter
        val alpha = 0.96
        filteredAngleX = alpha * (filteredAngleX + deltaGyroAngleX) + (1.0 - alpha) * accelAngleX
        filteredAngleY = alpha * (filteredAngleY + deltaGyroAngleY) + (1.0 - alpha) * accelAngleY
        filteredAngleZ = filteredAngleZ + deltaGyroAngleZ
    }

    /**
     * Get the last acceleration values, in g, retrieved from the accelerometer,
     * for the x, y and z axis.
     *
     * *(using the updating thread)*
     * @return the accelerations for the x, y and z axis. [-1, -1, -1] if the updating thread isn't running.
     */
    fun getAccelAccelerations(): DoubleArray? {
        if (updatingThreadStopped) return doubleArrayOf(-1.0, -1.0, -1.0)
        return doubleArrayOf(accelAccelerationX, accelAccelerationY, accelAccelerationZ)
    }

    /**
     * Get the last angle values, in °, retrieved from the accelerometer,
     * for the x, y and z axis.
     *
     * *(using the updating thread)*
     * @return the angle values for the x, y and z axis. [-1, -1, -1] if the updating thread isn't running.
     */
    fun getAccelAngles(): DoubleArray? {
        if (updatingThreadStopped) return doubleArrayOf(-1.0, -1.0, -1.0)
        return doubleArrayOf(accelAngleX, accelAngleY, accelAngleZ)
    }


    /**
     * Get the last angular speed values, in °/sec, retrieved from the gyroscope,
     * for the x, y and z axis.
     *
     * *(using the updating thread)*
     * @return the angular speed values for the x, y and z axis. [-1, -1, -1] if the updating thread isn't running.
     */
    fun getGyroAngularSpeeds(): DoubleArray? {
        if (updatingThreadStopped) return doubleArrayOf(-1.0, -1.0, -1.0)
        return doubleArrayOf(gyroAngularSpeedX, gyroAngularSpeedY, gyroAngularSpeedZ)
    }


    /**
     * Get the last angles values, in °, retrieved from the gyroscope,
     * for the x, y and z axis.
     *
     * *(using the updating thread)*
     * @return the angles values from the gyroscope for the x, y and z axis. [-1, -1, -1] if the updating thread isn't running.
     */
    fun getGyroAngles(): DoubleArray? {
        if (updatingThreadStopped) return doubleArrayOf(-1.0, -1.0, -1.0)
        return doubleArrayOf(gyroAngleX, gyroAngleY, gyroAngleZ)
    }

    /**
     * Get the calculated offsets for the angular speeds from the gyroscope,
     * for the x, y and z axis.
     *
     * *(calculated with the calibration function)*
     * @return the offsets for the angular speeds from the gyroscope.
     */
    fun getGyroAngularSpeedsOffsets(): DoubleArray? {
        return doubleArrayOf(gyroAngularSpeedOffsetX, gyroAngularSpeedOffsetY, gyroAngularSpeedOffsetZ)
    }

    /**
     * Last angle value, in °, calculated from the accelerometer and the gyroscope,
     * for the x, y and z axis.
     *
     * *(using the updating thread)*
     * @return the angles values, in °, filtered with values from the accelerometer and the gyroscope.
     */
    fun getFilteredAngles(): DoubleArray? {
        if (updatingThreadStopped) return doubleArrayOf(-1.0, -1.0, -1.0)
        return doubleArrayOf(filteredAngleX, filteredAngleY, filteredAngleZ)
    }



    /* -----------------------------------------------------------------------
    *                              UTILS
    * -----------------------------------------------------------------------*/


    /**
     * Get the distance between two points.
     * @param a the first point.
     * @param b the second point.
     * @return the distance between a and b.
     */
    private fun distance(a: Double, b: Double): Double {
        return sqrt(a * a + b * b)
    }

    private fun getAccelXAngle(x: Double, y: Double, z: Double): Double {
        // v1 - 360
        var radians = atan2(y, distance(x, z))
        var delta = 0.0
        if (y >= 0) {
            if (z >= 0) {
                // pass
            } else {
                radians *= -1.0
                delta = 180.0
            }
        } else {
            if (z <= 0) {
                radians *= -1.0
                delta = 180.0
            } else {
                delta = 360.0
            }
        }
        return radians * RADIAN_TO_DEGREE + delta
    }

    private fun getAccelYAngle(x: Double, y: Double, z: Double): Double {
        // v2
        var tan = -1 * x / distance(y, z)
        var delta = 0.0
        if (x <= 0) {
            if (z >= 0) {
                // q1
                // nothing to do
            } else {
                // q2
                tan *= -1.0
                delta = 180.0
            }
        } else {
            if (z <= 0) {
                // q3
                tan *= -1.0
                delta = 180.0
            } else {
                // q4
                delta = 360.0
            }
        }

        return atan(tan) * RADIAN_TO_DEGREE + delta
    }

    private fun getAccelZAngle(): Double {
        return ACCEL_Z_ANGLE
    }

    /**
     * Returns the String representation of an angle, in the "x.xxxx°" format.
     * @param angle the angle to convert.
     * @return the String representation of an angle, in the "x.xxxx°" format.
     */
    fun angleToString(angle: Double): String {
        return String.format("%.4f", angle) + "°"
    }

    /**
     * Returns the String representation of an acceleration value, in the "x.xxxxxxg" format.
     * @param accel the acceleration to convert.
     * @return the String representation of an acceleration value, in the "x.xxxxxxg" format.
     */
    fun accelToString(accel: Double): String {
        return String.format("%.6f", accel) + "g"
    }

    /**
     * Returns the String representation of an angular speed value, in the "x.xxxx°/s" format.
     * @param angularSpeed the angular speed to convert.
     * @return the String representation of an angular speed value, in the "x.xxxx°/s" format.
     */
    fun angularSpeedToString(angularSpeed: Double): String {
        return String.format("%.4f", angularSpeed) + "°/s"
    }

    /**
     * Returns a String representation of a triplet of values, in the "x: X\t y: Y\t z: Z" format.
     * @param x the first value of the triplet.
     * @param y the second value of the triplet.
     * @param z the thirs value of the triplet.
     * @return a String representation of a triplet of values, in the "x: X\t y: Y\t z: Z" format.
     */
    fun xyzValuesToString(x: String, y: String?, z: String?): String {
        return "x: " + x + "\ty: " + y + "\tz: " + z
    }



    companion object {
        //region DEFAULT VALUES
        /**
         * Coefficient to convert an angle value from radians to degrees.
         */
        val RADIAN_TO_DEGREE: Double = 180.0 / Math.PI

        /**
         * It is impossible to calculate an angle for the z axis from the accelerometer.
         */
        const val ACCEL_Z_ANGLE: Double = 0.0

        //Default address of the MPU6050 device.
        const val DEFAULT_MPU6050_ADDRESS: Int = 0x68

        //Default value for the digital low pass filter (DLPF) setting for both gyroscope and accelerometer.
        const val DEFAULT_DLPF_CFG: Int = 0x06

        //Default value for the sample rate divider.
        const val DEFAULT_SMPLRT_DIV: Int = 0x00
        //endregion

        //region REGISTERS ADDRESSES

        //Sample Rate Divider. This register specifies the divider from the gyroscope output rate used to generate
        const val MPU6050_REG_ADDR_SMPRT_DIV: Int = 0x19

        //Configuration. his register configures the external Frame Synchronization (FSYNC) pin sampling and
        //the Digital Low Pass Filter (DLPF) setting for both the gyroscopes and accelerometers.
        const val MPU6050_REG_ADDR_CONFIG: Int = 0x1A

        //Gyroscope Configuration. This register is used to trigger gyroscope self-test
        //and configure the gyroscopes’ full scale range
        const val MPU6050_REG_ADDR_GYRO_CONFIG: Int = 0x1B

        //Accelerometer Configuration. This register is used to trigger accelerometer self test and configure
        //the accelerometer full scale range. This register also configures the Digital High Pass Filter (DHPF).
        const val MPU6050_REG_ADDR_ACCEL_CONFIG: Int = 0x1C

        //Interrupt Enable. This register enables interrupt generation by interrupt sources
        const val MPU6050_REG_ADDR_INT_ENABLE: Int = 0x1A

        //Power Management 1. This register allows the user to configure the power mode and clock source.
        // It also provides a bit for resetting the entire device, and a bit for disabling the temperature sensor.
        const val MPU6050_REG_ADDR_PWR_MGMT_1: Int = 0x6B

        //Power Management 2. This register allows the user to configure the frequency of wake-ups in Accelerometer
        // Only Low Power Mode. This register also allows the user to put individual axes of the accelerometer
        // and gyroscope into standby mode.
        const val MPU6050_REG_ADDR_PWR_MGMT_2: Int = 0x6C

        //Accelerometer Measurements. These registers store the most recent accelerometer measurements.
        // #MPU6050_REG_ADDR_ACCEL_XOUT_L
        // #MPU6050_REG_ADDR_ACCEL_YOUT_H
        // #MPU6050_REG_ADDR_ACCEL_YOUT_L
        // #MPU6050_REG_ADDR_ACCEL_ZOUT_H
        // #MPU6050_REG_ADDR_ACCEL_ZOUT_L
        const val MPU6050_REG_ADDR_ACCEL_XOUT_H: Int = 0x3B
        const val MPU6050_REG_ADDR_ACCEL_XOUT_L: Int = 0x3C
        const val MPU6050_REG_ADDR_ACCEL_YOUT_H: Int = 0x3D
        const val MPU6050_REG_ADDR_ACCEL_YOUT_L: Int = 0x3E
        const val MPU6050_REG_ADDR_ACCEL_ZOUT_H: Int = 0x3F
        const val MPU6050_REG_ADDR_ACCEL_ZOUT_L: Int = 0x40

        //Temperature Measurement. These registers store the most recent temperature sensor measurement.
        const val MPU6050_REG_ADDR_TEMP_OUT_H: Int = 0x41

        //Temperature Measurement. These registers store the most recent temperature sensor measurement.
        const val MPU6050_REG_ADDR_TEMP_OUT_L: Int = 0x42

        //Gyroscope Measurements. These registers store the most recent gyroscope measurements.
        // #MPU6050_REG_ADDR_GYRO_XOUT_L
        // #MPU6050_REG_ADDR_GYRO_YOUT_H
        // #MPU6050_REG_ADDR_GYRO_YOUT_L
        // #MPU6050_REG_ADDR_GYRO_ZOUT_H
        // #MPU6050_REG_ADDR_GYRO_ZOUT_L
        const val MPU6050_REG_ADDR_GYRO_XOUT_H = 0x43
        const val MPU6050_REG_ADDR_GYRO_XOUT_L = 0x44
        const val MPU6050_REG_ADDR_GYRO_YOUT_H = 0x45
        const val MPU6050_REG_ADDR_GYRO_YOUT_L = 0x46
        const val MPU6050_REG_ADDR_GYRO_ZOUT_H = 0x47
        const val MPU6050_REG_ADDR_GYRO_ZOUT_L = 0x48

        //endregion

    }
}