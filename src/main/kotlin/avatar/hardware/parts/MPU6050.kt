package avatar.hardware.parts

import avatar.hardware.parts.basecomponents.I2CDevice
import avatar.hardware.parts.basecomponents.PositionSensor
import brain.data.local.Configuration
import brain.data.local.Position
import brain.utils.toI2CDeviceConfiguration
import com.pi4j.context.Context
import com.pi4j.io.i2c.I2C
import kotlinx.coroutines.*

class MPU6050(pi4j: Context, positionSensorConfig: Configuration.PositionSensorConfig): PositionSensor, I2CDevice(
    pi4j = pi4j, i2CDeviceConfiguration = positionSensorConfig.toI2CDeviceConfiguration()
) {

    //Value used for the DLPF config.
    private var dlpfCfg: Int = positionSensorConfig.dlpfCfg ?: 0
    //Value used for the sample rate divider.
    private var smplrtDiv: Int = positionSensorConfig.smplrtDiv ?: 0
    //Sensitivity of the measures from the accelerometer. Used to convert accelerometer values.
    private var accelLSBSensitivity: Double = 0.0
    //Sensitivity of the measures from the gyroscope. Used to convert gyroscope values to degrees/sec.
    private var gyroLSBSensitivity: Double = 0.0

    private var updatingJob: Job? = null
    private var updatingThreadStopped: Boolean = true
    private var lastUpdateTime: Long = 0

    // ACCELEROMETER
    //Last acceleration value, in g, retrieved from the accelerometer, for the X axis. (using updatingJob)
    private var accelAccelerationX: Double = 0.0
    //Last acceleration value, in g, retrieved from the accelerometer, for the Y axis. (using updatingJob)
    private var accelAccelerationY: Double = 0.0
    //Last acceleration value, in g, retrieved from the accelerometer, for the Z axis. (using updatingJob)
    private var accelAccelerationZ: Double = 0.0
    //Last angle value, in °, retrieved from the accelerometer, for the X axis. (using updatingJob)
    private var accelAngleX: Double = 0.0
    //Last angle value, in °, retrieved from the accelerometer, for the Y axis. (using updatingJob)
    private var accelAngleY: Double = 0.0
    //Last angle value, in °, retrieved from the accelerometer, for the Z axis. (using updatingJob)
    private var accelAngleZ: Double = 0.0

    //GYROSCOPE
    //Last angular speed value, in °/sec, retrieved from the gyroscope, for the X axis. (using updatingJob)
    private var gyroAngularSpeedX: Double = 0.0
    //Last angular speed value, in °/sec, retrieved from the gyroscope, for the Y axis. (using updatingJob)
    private var gyroAngularSpeedY: Double = 0.0
    //Last angular speed value, in °/sec, retrieved from the gyroscope, for the Z axis. (using updatingJob)
    private var gyroAngularSpeedZ: Double = 0.0
    //Last angle value, in °, calculated from the gyroscope, for the X axis. (using updatingJob)
    private var gyroAngleX: Double = 0.0
    //Last angle value, in °, calculated from the gyroscope, for the Y axis. (using updatingJob)
    private var gyroAngleY: Double = 0.0
    //Last angle value, in °, calculated from the gyroscope, for the Z axis. (using updatingJob)
    private var gyroAngleZ: Double = 0.0
    //Calculated offset for the angular speed from the gyroscope, for the X axis.
    private var gyroAngularSpeedOffsetX: Double = 0.0
    //Calculated offset for the angular speed from the gyroscope, for the Y axis.
    private var gyroAngularSpeedOffsetY: Double = 0.0
    //Calculated offset for the angular speed from the gyroscope, for the Z axis.
    private var gyroAngularSpeedOffsetZ: Double = 0.0

    //FILTERED
    //Last angle value, in °, calculated from the accelerometer and the gyroscope, for the X axis. (using updatingJob)
    private var filteredAngleX: Double = 0.0
    //Last angle value, in °, calculated from the accelerometer and the gyroscope, for the Y axis. (using updatingJob)
    private var filteredAngleY: Double = 0.0
    //Last angle value, in °, calculated from the accelerometer and the gyroscope, for the Z axis. (using updatingJob)
    private var filteredAngleZ: Double = 0.0



    override fun initDevice(i2C: I2C) {
        // 1. waking up the MPU6050 (0x00 = 0000 0000) as it starts in sleep mode.
        updateRegisterValue(MPU6050_REG_ADDR_PWR_MGMT_1, 0x00)

        // 2. sample rate divider
        // The sensor register output, FIFO output, and DMP sampling are all based on the Sample Rate.
        // The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:
        //      Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
        // where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or 7),
        // and 1kHz when the DLPF is enabled (see register 26).
        // SMPLRT_DIV set the rate to the default value : Sample Rate = Gyroscope Rate.
        updateRegisterValue(MPU6050_REG_ADDR_SMPRT_DIV, smplrtDiv)

        // 3. This register configures the external Frame Synchronization (FSYNC)
        // pin sampling and the Digital Low Pass Filter (DLPF) setting for both
        // the gyroscopes and accelerometers.
        setDLPFConfig(dlpfCfg)


        // 4. Gyroscope configuration
        // FS_SEL selects the full scale range of the gyroscope outputs.
        val fsSel = (0 shl 3).toByte() // FS_SEL +- 250 °/s
        gyroLSBSensitivity = 131.0 // cfr [datasheet 2 - p.31]
        updateRegisterValue(MPU6050_REG_ADDR_GYRO_CONFIG, fsSel.toInt())


        // 5. Accelerometer configuration [datasheet 2 - p.29]
        val afsSel: Byte = 0 // AFS_SEL full scale range: ± 2g. LSB sensitivity : 16384 LSB/g
        accelLSBSensitivity = 16384.0 // LSB Sensitivity corresponding to AFS_SEL 0
        updateRegisterValue(MPU6050_REG_ADDR_ACCEL_CONFIG, afsSel.toInt())

        // 6. Disable interrupts
        updateRegisterValue(MPU6050_REG_ADDR_INT_ENABLE, 0x00)

        // 7. Disable standby mode
        updateRegisterValue(MPU6050_REG_ADDR_PWR_MGMT_2, 0x00)

        calibrateSensor()
    }

    /* -----------------------------------------------------------------------
     *                             METHODS
     * -----------------------------------------------------------------------*/
    //TODO finish here on line 573



    override fun reset() {
    }

    override fun getPositionData(): Position {
        //TODO("Not yet implemented")
        return Position(0, "MPU6050", "BBOON")
    }

    override fun getGyroscopePositionData(): Position {
        TODO("Not yet implemented")
        return Position(0, "MPU6050", "BBOON")
    }

    override fun getGPSPositionData(): Position {
        TODO("Not yet implemented")
        return Position(0, "MPU6050", "BBOON")
    }


    /** Calibrate the accelerometer and gyroscope sensors. */
    private fun calibrateSensor() {
        val calibrateThread = CoroutineScope(Job() + Dispatchers.IO).launch {
            println("Calibration starting in 5 seconds (don't move the sensor).")
            delay(5000)
            println("Calibration started (~5s) (don't move the sensor).")

            val nbReadings = 50
            // Gyroscope offsets
            gyroAngularSpeedOffsetX = 0.0
            gyroAngularSpeedOffsetY = 0.0
            gyroAngularSpeedOffsetZ = 0.0
            for (i in 0..<nbReadings) {
                val angularSpeeds: DoubleArray = readScaledGyroscopeValues()
                gyroAngularSpeedOffsetX += angularSpeeds[0]
                gyroAngularSpeedOffsetY += angularSpeeds[1]
                gyroAngularSpeedOffsetZ += angularSpeeds[2]
                delay(100)
            }
            gyroAngularSpeedOffsetX /= nbReadings.toDouble()
            gyroAngularSpeedOffsetY /= nbReadings.toDouble()
            gyroAngularSpeedOffsetZ /= nbReadings.toDouble()
            println("Calibration ended")
        }
    }

    /* -----------------------------------------------------------------------
    *                              UTILS
    * -----------------------------------------------------------------------*/


    /**
     * This method updates the value of a specific register with a specific value.
     * The method also checks that the update was successfull.
     * @param address the address of the register to update.
     * @param value the new value to set in the register.
     */
    fun updateRegisterValue(address: Int, value: Int) {
        writeRegister(address, value)

        // we check that the value of the register has been updated
        val readRegisterValue: Int = readRegister(address)

        if (readRegisterValue != value) throw Exception(
            "Error when updating the MPU6050 register value (register: " +
                    address + ", value: " + value + ")"
        )
    }

    fun setDLPFConfig(dlpfConfig: Int) {
        if(dlpfConfig > 7 || dlpfConfig < 0) {
            throw Exception("The DLPF config must be in the 0..7 range.")
        }
        dlpfCfg = dlpfConfig
        updateRegisterValue(MPU6050_REG_ADDR_CONFIG, dlpfCfg)
    }

    /**
     * Reads the most recent gyroscope values on the MPU6050 for X, Y and Z axis,
     * and calculates the corresponding angular speeds in degrees/sec,
     * according to the selected FS_SEL mode.
     * @return [GYRO_X, GYRO_Y, GYRO_Z], the angular velocities in degrees/sec for the x, y and z axis.
     */
    fun readScaledGyroscopeValues(): DoubleArray {
        var gyroX: Double = readWord2C(MPU6050_REG_ADDR_GYRO_XOUT_H).toDouble()
        gyroX /= gyroLSBSensitivity
        var gyroY: Double = readWord2C(MPU6050_REG_ADDR_GYRO_YOUT_H).toDouble()
        gyroY /= gyroLSBSensitivity
        var gyroZ: Double = readWord2C(MPU6050_REG_ADDR_GYRO_ZOUT_H).toDouble()
        gyroZ /= gyroLSBSensitivity

        return doubleArrayOf(gyroX, gyroY, gyroZ)
    }

    /**
     * Reads the content of two consecutive registers, starting at registerAddress,
     * and returns the int representation of the combination of those registers,
     * with a two's complement representation.
     * @param registerAddress the address of the first register to read.
     * @return the int representation of the combination of the two consecutive
     * registers, with a two's complement representation.
     */
    private fun readWord2C(registerAddress: Int): Int {
        var value: Int = readRegisterValue(registerAddress)
        value = value shl 8
        value += readRegisterValue(registerAddress + 1)

        if (value >= 0x8000) value = -(65536 - value)
        return value
    }

    /**
     * Reads the content of a specific register of the MPU6050.
     * @param registerAddress the address of the register to read.
     * @return the int representation of the content of the register.
     */
    private fun readRegisterValue(registerAddress: Int): Int {
        return readUnsignedRegisterValue(registerAddress)
    }


    companion object {
        //region DEFAULT VALUES

        //Default address of the MPU6050 device.
        const val DEFAULT_MPU6050_ADDRESS: Int = 0x68

        //Default value for the digital low pass filter (DLPF) setting for both gyroscope and accelerometer.
        const val DEFAULT_DLPF_CFG: Int = 0x06

        //Default value for the sample rate divider.
        const val DEFAULT_SMPLRT_DIV: Int = 0x00
        //endregion

        //region REGISTERS ADDRESSES

        //Sample Rate Divider. This register specifies the divider from the gyroscope output rate used to generate
        const val MPU6050_REG_ADDR_SMPRT_DIV: Int = 0x19

        //Configuration. his register configures the external Frame Synchronization (FSYNC) pin sampling and
        //the Digital Low Pass Filter (DLPF) setting for both the gyroscopes and accelerometers.
        const val MPU6050_REG_ADDR_CONFIG: Int = 0x1A

        //Gyroscope Configuration. This register is used to trigger gyroscope self-test
        //and configure the gyroscopes’ full scale range
        const val MPU6050_REG_ADDR_GYRO_CONFIG: Int = 0x1B

        //Accelerometer Configuration. This register is used to trigger accelerometer self test and configure
        //the accelerometer full scale range. This register also configures the Digital High Pass Filter (DHPF).
        const val MPU6050_REG_ADDR_ACCEL_CONFIG: Int = 0x1C

        //Interrupt Enable. This register enables interrupt generation by interrupt sources
        const val MPU6050_REG_ADDR_INT_ENABLE: Int = 0x1A

        //Power Management 1. This register allows the user to configure the power mode and clock source.
        // It also provides a bit for resetting the entire device, and a bit for disabling the temperature sensor.
        const val MPU6050_REG_ADDR_PWR_MGMT_1: Int = 0x6B

        //Power Management 2. This register allows the user to configure the frequency of wake-ups in Accelerometer
        // Only Low Power Mode. This register also allows the user to put individual axes of the accelerometer
        // and gyroscope into standby mode.
        const val MPU6050_REG_ADDR_PWR_MGMT_2: Int = 0x6C

        //Accelerometer Measurements. These registers store the most recent accelerometer measurements.
        // #MPU6050_REG_ADDR_ACCEL_XOUT_L
        // #MPU6050_REG_ADDR_ACCEL_YOUT_H
        // #MPU6050_REG_ADDR_ACCEL_YOUT_L
        // #MPU6050_REG_ADDR_ACCEL_ZOUT_H
        // #MPU6050_REG_ADDR_ACCEL_ZOUT_L
        const val MPU6050_REG_ADDR_ACCEL_XOUT_H: Int = 0x3B
        const val MPU6050_REG_ADDR_ACCEL_XOUT_L: Int = 0x3C
        const val MPU6050_REG_ADDR_ACCEL_YOUT_H: Int = 0x3D
        const val MPU6050_REG_ADDR_ACCEL_YOUT_L: Int = 0x3E
        const val MPU6050_REG_ADDR_ACCEL_ZOUT_H: Int = 0x3F
        const val MPU6050_REG_ADDR_ACCEL_ZOUT_L: Int = 0x40

        //Temperature Measurement. These registers store the most recent temperature sensor measurement.
        const val MPU6050_REG_ADDR_TEMP_OUT_H: Int = 0x41

        //Temperature Measurement. These registers store the most recent temperature sensor measurement.
        const val MPU6050_REG_ADDR_TEMP_OUT_L: Int = 0x42

        //Gyroscope Measurements. These registers store the most recent gyroscope measurements.
        // #MPU6050_REG_ADDR_GYRO_XOUT_L
        // #MPU6050_REG_ADDR_GYRO_YOUT_H
        // #MPU6050_REG_ADDR_GYRO_YOUT_L
        // #MPU6050_REG_ADDR_GYRO_ZOUT_H
        // #MPU6050_REG_ADDR_GYRO_ZOUT_L
        const val MPU6050_REG_ADDR_GYRO_XOUT_H = 0x43
        const val MPU6050_REG_ADDR_GYRO_XOUT_L = 0x44
        const val MPU6050_REG_ADDR_GYRO_YOUT_H = 0x45
        const val MPU6050_REG_ADDR_GYRO_YOUT_L = 0x46
        const val MPU6050_REG_ADDR_GYRO_ZOUT_H = 0x47
        const val MPU6050_REG_ADDR_GYRO_ZOUT_L = 0x48

        //endregion

    }
}